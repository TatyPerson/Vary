// automatically generated by Xtext
grammar vary.pseudocodigo.dsl.c.english.VaryGrammarEnglish with org.eclipse.xtext.common.Terminals

import "http://diagramapseudocodigo/1.0" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Codigo returns Codigo:
	Algoritmo | Modulo;
	
Algoritmo returns Algoritmo:
	'Algorithm' nombre=EString
	(comentarios+=Comentario (comentarios+=Comentario)* )?
	('import'
	(importaciones+=[Modulo] (importaciones+=[Modulo])* )?
	'end_import')?
	('const'
		( constantes+=Constantes (constantes+=Constantes)* )? )?
	('type'
		( tipocomplejo+=TipoComplejo (tipocomplejo+=TipoComplejo)* )? )?
	('var'
		( global+=Declaracion ( global+=Declaracion)* )? )?
	(funcion+=Subproceso (funcion+=Subproceso)* )?
	tiene=Inicio
	'end_algorithm';
	
Modulo returns Modulo:
	'Module' nombre=ID
	'import'
	(importaciones+=[Modulo] (importaciones+=[Modulo])* )?
	'end_import'
	'export'
	('const'
	(exporta_constantes+=EString (exporta_constantes+=EString)* )? )?
	('type'
	(exporta_tipos+=EString (exporta_tipos+=EString)* )? )?
	('var'
		( exporta_global+=Declaracion ( exporta_global+=Declaracion)* )? )?
	(exporta_funciones+=CabeceraSubproceso (exporta_funciones+=CabeceraSubproceso)* )?
	'end_export'
	implementacion=Implementacion
	'end_module';

Implementacion returns Implementacion:
	{Implementacion}
	'implementation'
	('const'
		( constantes+=Constantes (constantes+=Constantes)* )? )?
	('type'
		( tipocomplejo+=TipoComplejo (tipocomplejo+=TipoComplejo)* )? )?
	('var'
		( global+=Declaracion ( global+=Declaracion)* )? )?
	(funcion+=Subproceso (funcion+=Subproceso)* )?
	'end_implementation'
;

CabeceraSubproceso returns CabeceraSubproceso:
	CabeceraProcedimiento | CabeceraFuncion;
	
CabeceraProcedimiento returns CabeceraProcedimiento:
	'procedure'
	nombre=NOMBRE_FUN
	(parametrofuncion+=ParametroFuncion ( "," parametrofuncion+=ParametroFuncion)*  )?')';
	
CabeceraFuncion returns CabeceraFuncion:
	tipo=TipoVariable 'function'
	nombre=NOMBRE_FUN
	(parametrofuncion+=ParametroFuncion ( "," parametrofuncion+=ParametroFuncion)*  )?')';

	
TipoComplejo returns TipoComplejo:
	Vector | Matriz | Registro | Archivo | Enumerado | Subrango;


Subproceso returns Subproceso:
	Funcion | Procedimiento;

//terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')? ;

Comentario returns Comentario:
	{Comentario}/* ML_COMMENT | */ SL_COMMENT mensaje= COMENT;

Sentencias returns Sentencias:
	 Escribir | Leer | Bloque | FuncionFicheroAbrir | FuncionFicheroCerrar | Asignacion | Funciones;

Bloque returns Bloque:
	Si | mientras | repetir | desde | segun;

Declaracion returns Declaracion:
	DeclaracionVariable | DeclaracionPropia;
	
FuncionFicheroAbrir returns FuncionFicheroAbrir:
	'open'
	'('
		(variable+=Primaria ',' modo=ModoApertura ',' variable+=Primaria)
	')'
;

FuncionFicheroCerrar returns FuncionFicheroCerrar:
	'close'
	'('
		(variable=Primaria)
	')'
;
	
ModoApertura returns ModoApertura:
	'writing' | 'reading';

terminal NOMBRE_FUN: ('a'..'z'|'A'..'Z'|'0'..'9'|'_')* ('(');

NombreInterna returns NombreInterna:
	'cos(' | 'square(' | 'exp(' | 'ln(' | 'log(' | 'sen(' | 'sqrt(' | 'length(' | 'concatena(';


EInt returns ecore::EInt:
	INT;
	 
//terminal EXPONENT: ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

EFloat returns ecore::EFloat:
	INT '.' INT (('E'|'e') ('+'|'-')? INT)?;   
	//('0'..'9')+ '.' ('0'..'9')* EXPONENT?
    //|   '.' ('0'..'9')+ EXPONENT?
    //|   ('0'..'9')+ EXPONENT
    //;

//ValorRegistro returns ValorRegistro:
//	nombre_registro=EString '.' (campo+=CampoRegistro ('.' campo+=CampoRegistro)* );
	
//ValorVector returns ValorVector:
//	((nombre_vector=EString)'['(indice=NumeroEntero | indice=VariableID)']') ('.' (campo+=CampoRegistro) )?;
	
CampoRegistro returns CampoRegistro:
	nombre_campo=EString;

Tipo returns Tipo:
	TipoDefinido | TipoExistente;
	
TipoDefinido returns TipoDefinido:
	tipo=EString;

TipoExistente returns TipoExistente:
	tipo=TipoVariable;

Constantes returns Constantes:
	variable=Variable '=' valor=Primaria;

Vector returns Vector:
	'vector' '['(valor=Primaria)']' 'of'  tipo=Tipo ': ' nombre=EString;

Matriz returns Matriz:
	'matrix' '['(valor+=Primaria)']['(valor+=Primaria)']' 'of' tipo=Tipo ': ' nombre=EString;
	

Registro returns Registro:
	'registry:' nombre=EString
			(variable+=Declaracion (variable+=Declaracion)* )
	'end_registry';
	
Archivo returns Archivo:
	'archive of ' tipo=Tipo': ' nombre=EString;
	

Enumerado returns Enumerado:
	nombre=EString '=' '{'(valor+=Primaria (',' valor+=Primaria )* )'}';
	
Subrango returns Subrango:
	SubrangoNumerico | SubrangoEnumerado;

SubrangoNumerico returns SubrangoNumerico:
	nombre=EString '=' (limite_inf=EInt '..' limite_sup=EInt);
	
SubrangoEnumerado returns SubrangoEnumerado:
	nombre=EString '=' (limite_inf=EString '..' limite_sup=EString);

Inicio returns Inicio:
	'main'
	{Inicio}
	'var'
	( declaracion+=Declaracion ( declaracion+=Declaracion)* )?
	'initiation'
		(tiene+=Sentencias (  tiene+=Sentencias)*  )?
	'end_main';

EString returns ecore::EString:
	STRING | ID;

DeclaracionVariable returns DeclaracionVariable:
	tipo=TipoVariable ': '
	variable+=Variable ( ',' variable+=Variable)*;
	
DeclaracionPropia returns DeclaracionPropia:
	tipo=EString ': '
	variable+=Variable (',' variable+=Variable)*;

Asignacion returns Asignacion:
	AsignacionNormal | AsignacionCompleja;
	
AsignacionNormal returns AsignacionNormal:
	valor_asignacion=EString
//	 Mat+=MAT*
	'<-'
	operador=operacion;
	
AsignacionCompleja returns AsignacionCompleja:
	valor_asignacion=VariablesComplejas
	'<-'
	operador=operacion;

//AsignacionCompleja returns AsignacionCompleja:
//	operadores+=Primaria
//	Mat+=MAT*
//	 '='
//	operadores+=Primaria;

Escribir returns Escribir:
	'write('
		 operador+=Primaria ( "," operador+=Primaria | operador+=operacion)* 
	')';

Leer returns Leer:
	'read('
		variable+=Primaria ( "," variable+=Primaria)*
	')';

Si returns Si:
	'if' 
	'(' 
	valor=operacion
	')' 'then'
		(sentencias+=Sentencias ( sentencias+=Sentencias)* )?
		(devuelve=Devolver)?
	(sino=Sino)?
	'end_if';

mientras returns mientras:
	'while'
	'('
	valor=operacion
	')' 'do'
		(sentencias+=Sentencias ( sentencias+=Sentencias)*  )?
	'end_while';

repetir returns repetir:
	'repeat'
		(sentencias+=Sentencias ( sentencias+=Sentencias)*)?
	 'until' 
	 '('
	 valor=operacion ')';

desde returns desde:
	'for' asignacion=AsignacionNormal 'to' valor=operacion 'do'
		(sentencias+=Sentencias ( sentencias+=Sentencias)* )?
	'end_for';
	
Caso returns Caso:
	'case' operador=Primaria ': ' (sentencias+=Sentencias ( sentencias+=Sentencias )* )?
	(devuelve=Devolver)?
;
	
segun returns segun:
	'according_to''('valor=Primaria')' 'do'
		(caso+=Caso ( caso+=Caso )* )?
		'otherwise:'
		(sentencias+=Sentencias ( sentencias+=Sentencias )* )?
		(devuelve=Devolver)?
	'end_according_to';

//negacion returns negacion:
//	nombre=EString
//	ssigno=neg;
	
//unaria returns unaria:
//	ssigno=neg
//	variable=Primaria;

TipoVariable returns ecore::EString:
	'integer' | 'character' | 'real' | 'boolean' | 'string';
	
Variable returns Variable:
	 {Variable} nombre=EString;
//	 Mat+=MAT*;

//VariableID returns VariableID:
//	{VariableID} nombre=EString;
	//Mat+=MAT*;

terminal CAD: '"' ('a'..'z'|'A'..'Z'|'_'|'-'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9'|':'|','|'.')* '"';
terminal CAR: "'" ('a'..'z'|'A'..'Z'|'_'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9') "'";
terminal COMENT: '/*' ('a'..'z'|'A'..'Z'|'_'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9')* '*/';

//terminal MAT: 
//'[' ('a'..'z'|'A'..'Z'|'0'..'9')*('--'|'++')? ']' ;


//ConstCadena returns ConstCadena:
//	{ConstCadena} contenido=CAD;

//NumeroEntero returns NumeroEntero:
//	 {NumeroEntero} valor=INTEGER;

//NumeroDecimal returns NumeroDecimal:
//	 {NumeroDecimal} valor=FLOAT;

//ValorBooleano returns ValorBooleano:
//	 {ValorBooleano} valor=booleano;

signo returns signo:
	('+' | '-' | '*' | '/' | '<' | '>' | '>=' | '<=' | 'y' | 'o' | '=' | '!=' | 'mod' | 'div')
 /* TODO: implement this rule and an appropriate IValueConverter */;
 
signoOr returns signo:
	'or';

signoAnd returns signo:
	'and';
	
signoIgualdad returns signo:
	'=' | '!=';
	
signoComparacion returns signo:
	'<' | '>' | '>=' | '<=';

signoSuma returns signo:
	'+';
	
signoResta returns signo:
	'-';
	
signoMultiplicacion returns signo:
	'*';
	
signoDivision returns signo:
	'/';
	
signoModulo returns signo:
	'mod';
	
signoDiv returns signo:
	'div';

operacion returns operacion:
	Or;

Or returns operacion:
	And ({Or.left=current} signo_op=signoOr right=And)*;

And returns operacion:
	Mod ({And.left=current} signo_op=signoAnd right=Mod)*;
	
Mod returns operacion:
	Igualdad ({Mod.left=current} signo_op=signoModulo right=Igualdad)*;

Igualdad returns operacion:
	Comparacion ({Igualdad.left=current} signo_op=signoIgualdad right=Comparacion)*;

Comparacion returns operacion:
	SumaResta ({Comparacion.left=current} signo_op=signoComparacion right=SumaResta)*;

SumaResta returns operacion:
	MultiplicacionDivision (({Suma.left=current} signo_op=signoSuma | {Resta.left=current} signo_op=signoResta) right=MultiplicacionDivision)*;

MultiplicacionDivision returns operacion:
	Primaria (({Multiplicacion.left=current} signo_op=signoMultiplicacion | {Division.left=current} signo_op=signoDivision | {Div.left=current} signo_op=signoDiv) right=Primaria)*;
	
	
operacionIndice returns operacion:
	OrIndice;

OrIndice returns operacion:
	AndIndice ({Or.left=current} signo_op=signoOr right=AndIndice)*;

AndIndice returns operacion:
	IgualdadIndice ({And.left=current} signo_op=signoAnd right=IgualdadIndice)*;

IgualdadIndice returns operacion:
	ComparacionIndice ({Igualdad.left=current} signo_op=signoIgualdad right=ComparacionIndice)*;

ComparacionIndice returns operacion:
	SumaRestaIndice ({Comparacion.left=current} signo_op=signoComparacion right=SumaRestaIndice)*;

SumaRestaIndice returns operacion:
	MultiplicacionDivisionIndice (({Suma.left=current} signo_op=signoSuma | {Resta.left=current} signo_op=signoResta) right=MultiplicacionDivisionIndice)*;

MultiplicacionDivisionIndice returns operacion:
	PrimariaIndice (({Multiplicacion.left=current} signo_op=signoMultiplicacion | {Division.left=current} signo_op=signoDivision | {Div.left=current} signo_op=signoDiv) right=PrimariaIndice)*;

PrimariaIndice returns operacion:
	{NumeroEntero} valor=EInt
	| {VariableID} nombre=EString;

Primaria returns operacion:
	VariablesBasicas |
	VariablesComplejas
	| {Negativa} '-(' valor_operacion=operacion ')'
	| {Negacion} 'not''(' valor_operacion=operacion ')'
	| Funciones
	| {OperacionParentesis} '(' valor_operacion=operacion ')';
	
	
Funciones returns operacion:
	{LlamadaFuncion} (nombre=NOMBRE_FUN) (operadores+=operacion ( ',' operadores+=operacion)* )? ')'
	| {Internas} (nombre=NombreInterna) (operadores+=operacion ( ',' operadores+=operacion)* )? ')';
	
VariablesComplejas returns operacion:
	{ValorVector} ((nombre_vector=EString)'['(indice=operacionIndice)']') ('.' (campo+=CampoRegistro) )?
	| {ValorMatriz} ((nombre_matriz=EString)'['(primerIndice=operacionIndice)']['(segundoIndice=operacionIndice)']') ('.' (campo+=CampoRegistro) )?
	| {ValorRegistro} nombre_registro=EString '.' (campo+=CampoRegistro ('.' campo+=CampoRegistro)* );
	
VariablesBasicas returns operacion:
	 {NumeroEntero} valor=EInt
	| {NumeroDecimal} valor=EFloat
	| {ConstCadena} contenido=CAD
	| {Caracter} contenido=CAR
	| {ValorBooleano} valor=Booleano
	| {VariableID} nombre=EString;

Sino returns Sino:
	{Sino}
	'else'
	(sentencias+=Sentencias ( sentencias+=Sentencias)* )?
	(devuelve=Devolver)?;

Devolver returns Devolver:
	{Devolver}
	'return' devuelve=operacion;

//neg returns neg:
//	"no" /* TODO: implement this rule and an appropriate IValueConverter */;
	
ParametroFuncion returns ParametroFuncion:
	paso=TipoPaso
	tipo=Tipo ": "
	variable=Variable;

Funcion returns Funcion:
	(tipo=TipoVariable)
	'function'
	nombre=NOMBRE_FUN(parametrofuncion+=ParametroFuncion ( "," parametrofuncion+=ParametroFuncion)*  )?')'
	('var'
	( declaracion+=Declaracion ( declaracion+=Declaracion)* )? )?
	'initiation'
	( sentencias+=Sentencias (  sentencias+=Sentencias)*  )?
	(devuelve=Devolver)?
	'end_function';
	
Procedimiento returns Procedimiento:
	'procedure'
	nombre=NOMBRE_FUN(parametrofuncion+=ParametroFuncion ( "," parametrofuncion+=ParametroFuncion)*  )?')'
	('var'
	( declaracion+=Declaracion ( declaracion+=Declaracion)* )? )?
	'initiation'
	( sentencias+=Sentencias (  sentencias+=Sentencias)*  )?
	'end_procedure';
	
TipoPaso returns ecore::EString:
	'I' | 'I/O' | 'O';
	
Booleano returns ecore::EString:
	'true' | 'false';