// automatically generated by Xtext
grammar vary.pseudocodigo.dsl.c.VaryGrammar with org.eclipse.xtext.common.Terminals

import "http://diagramapseudocodigo/1.0" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Codigo returns Codigo:
	Algoritmo | Modulo;
	
Algoritmo returns Algoritmo:
	'Algoritmo' nombre=EString
	('importa'
	(importaciones+=[Modulo])*
	'fin_importa')?
	('const'
		(constantes+=Constante)* )? 
	('tipo'
		(complejos+=TipoComplejo)* )?
	('var'
		(globales+=Declaracion)* )? 
	(subprocesos+=Subproceso)*
	inicio=Inicio
	'fin_algoritmo';
	
Modulo returns Modulo:
	'Modulo' nombre=ID
	'importa'
	(importaciones+=[Modulo])* 
	'fin_importa'
	('exporta'
	('const'
		(exporta_constantes+=EString)* )? 
	('tipo'
		(exporta_tipos+=EString)* )?
	('var'
		(exporta_globales+=Declaracion)* )? 
	(exporta_subprocesos+=CabeceraSubproceso)* 
	'fin_exporta')
	implementacion=Implementacion
	'fin_modulo';

Implementacion returns Implementacion:
	{Implementacion}
	('implementacion'
	('const'
		(constantes+=Constante)* )?
	('tipo'
		(complejos+=TipoComplejo)* )?
	('var'
		(globales+=Declaracion)* )?
	(subprocesos+=Subproceso)*
	'fin_implementacion')
;

CabeceraSubproceso returns CabeceraSubproceso:
	CabeceraProcedimiento | CabeceraFuncion;
	
CabeceraProcedimiento returns CabeceraProcedimiento:
	'procedimiento'
	nombre=NOMBRE_FUN
	(parametros+=Parametro ( "," parametros+=Parametro)*  )?')';
	
CabeceraFuncion returns CabeceraFuncion:
	tipo=TipoVariable 'funcion'
	nombre=NOMBRE_FUN
	(parametros+=Parametro ( "," parametros+=Parametro)*  )?')';
	
TipoComplejo returns TipoComplejo:
	Vector | Matriz | Registro | Archivo | Enumerado | Subrango;

Subproceso returns Subproceso:
	Funcion | Procedimiento;

Comentario returns Comentario:
	mensaje=SL_COMMENT | mensaje=ML_COMMENT;

Sentencia returns Sentencia:
	 Escribir | Leer | Bloque | FuncionFicheroAbrir | FuncionFicheroCerrar | Asignacion | Funciones;

Bloque returns Bloque:
	Si | Mientras | Repetir | Desde | Segun;

Declaracion returns Declaracion:
	DeclaracionBasica | DeclaracionDefinida;
	
FuncionFicheroAbrir returns FuncionFicheroAbrir:
	'abrir('
		(variable+=Primaria ',' modo=ModoApertura ',' variable+=Primaria)
	')'
;

FuncionFicheroCerrar returns FuncionFicheroCerrar:
	'cerrar('
		(variable=Primaria)
	')'
;
	
ModoApertura returns ModoApertura:
	'escritura' | 'lectura';
	

terminal NOMBRE_FUN: ('a'..'z'|'A'..'Z'|'0'..'9'|'_')* ('(');


NombreInterna returns ecore::EString:
	'cos(' | 'cuadrado(' | 'exp(' | 'ln(' | 'log(' | 'sen(' | 'sqrt(' | 'longitud(' | 'concatena(' | 'copiar(';


EInt returns ecore::EInt:
	INT;
	 
//terminal EXPONENT: ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

EFloat returns ecore::EFloat:
	INT '.' INT (('E'|'e') INT)?;   
	//('0'..'9')+ '.' ('0'..'9')* EXPONENT?
    //|   '.' ('0'..'9')+ EXPONENT?
    //|   ('0'..'9')+ EXPONENT
    //;

//ValorRegistro returns ValorRegistro:
//	nombre_registro=EString '.' (campo+=CampoRegistro ('.' campo+=CampoRegistro)* );
	
//ValorVector returns ValorVector:
//	((nombre_vector=EString)'['(indice=NumeroEntero | indice=VariableID)']') ('.' (campo+=CampoRegistro) )?;

Tipo returns Tipo:
	TipoDefinido | TipoBasico;
	
TipoDefinido returns TipoDefinido:
	tipo=EString;

TipoBasico returns TipoBasico:
	tipo=TipoVariable;

Constante returns Constante:
	variable=Variable '=' valor=Primaria;

Vector returns Vector:
	'vector' '['(valor=Primaria)']' 'de'  tipo=Tipo ': ' nombre=EString;

Matriz returns Matriz:
	'matriz' '['(valor+=Primaria)']['(valor+=Primaria)']' 'de' tipo=Tipo ': ' nombre=EString;
	

Registro returns Registro:
	'registro:' nombre=EString
			(variable+=Declaracion)+
	'fin_registro';
	
Archivo returns Archivo:
	'archivo de ' tipo=Tipo': ' nombre=EString;
	

Enumerado returns Enumerado:
	nombre=EString '=' '{'(valor+=Primaria (',' valor+=Primaria )* )'}';
	
Subrango returns Subrango:
	SubrangoNumerico | SubrangoEnumerado;

SubrangoNumerico returns SubrangoNumerico:
	nombre=EString '=' (limite_inf=EInt '..' limite_sup=EInt);
	
SubrangoEnumerado returns SubrangoEnumerado:
	nombre=EString '=' (limite_inf=EString '..' limite_sup=EString);

Inicio returns Inicio:
	'principal'
	{Inicio}
	'var'
	(declaraciones+=Declaracion)*
	'inicio'
		(sentencias+=Sentencia)*
	'fin_principal';

EString returns ecore::EString:
	STRING | ID;

DeclaracionBasica returns DeclaracionBasica:
	tipo=TipoVariable ': '
	variables+=Variable ( ',' variables+=Variable)*;
	
DeclaracionDefinida returns DeclaracionDefinida:
	tipo=EString ': '
	variables+=Variable (',' variables+=Variable)*;

Asignacion returns Asignacion:
	AsignacionNormal | AsignacionCompleja;
	
AsignacionNormal returns AsignacionNormal:
	valor_asignacion=EString
//	 Mat+=MAT*
	'<-'
	operador=OperacionCompleta;
	
AsignacionCompleja returns AsignacionCompleja:
	valor_asignacion=VariablesComplejas
	'<-'
	operador=OperacionCompleta;

//AsignacionCompleja returns AsignacionCompleja:
//	operadores+=Primaria
//	Mat+=MAT*
//	 '='
//	operadores+=Primaria;

Escribir returns Escribir:
	'escribir('
		 operador+=Primaria ( "," operador+=OperacionCompleta)* 
	')';

Leer returns Leer:
	'leer(' 
		variable+=Primaria ( "," variable+=Primaria)*
	')';

Si returns Si:
	('si' 
	'(' | 'si(') valor=OperacionCompleta
	')' 'entonces'
		(sentencias+=Sentencia)*
		(devuelve=Devolver)?
	(sino=Sino)?
	'fin_si';

Mientras returns Mientras:
	('mientras'
	'(' | 'mientras(')
	valor=OperacionCompleta
	')' 'hacer'
		(sentencias+=Sentencia)* 
	'fin_mientras';

Repetir returns Repetir:
	'repetir'
		(sentencias+=Sentencia)*
	 ('hasta_que' '(' | 'hasta_que(')
	 valor=OperacionCompleta
	 ')';

Desde returns Desde:
	'desde' asignacion=AsignacionNormal 'hasta' valor=OperacionCompleta 'hacer'
		(sentencias+=Sentencia)*
	'fin_desde';
	
Caso returns Caso:
	'caso' operador=Primaria ': ' (sentencias+=Sentencia)* 
	(devuelve=Devolver)?
;

Segun returns Segun:
	('segun_sea''(' | 'segun_sea(') valor=OperacionCompleta')' 'hacer'
		(casos+=Caso )*
		'en_otro_caso:'
		(sentencias+=Sentencia)*
		(devuelve=Devolver)?
	'fin_segun';

//negacion returns negacion:
//	nombre=EString
//	ssigno=neg;
	
//unaria returns unaria:
//	ssigno=neg
//	variable=Primaria;

TipoVariable returns ecore::EString:
	'entero' | 'caracter' | 'real' | 'logico' | 'cadena';
	
Variable returns Variable:
	 {Variable} nombre=EString;
//	 Mat+=MAT*;

//VariableID returns VariableID:
//	{VariableID} nombre=EString;
	//Mat+=MAT*;

terminal CAD: '"' ('a'..'z'|'A'..'Z'|'_'|'-'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9'|':'|','|'.'|'á'|'é'|'í'|'ó'|'ú'|'ñ'|'Á'|'É'|'Í'|'Ó'|'Ú'|'Ñ')* '"';
terminal CAR: "'" ('a'..'z'|'A'..'Z'|'_'|' '|'!'|'#'|'@'|'%'|'&'|'('|')'|'='|'?'|'\\'|'0'..'9') "'";
 
signoOr returns signo:
	'o';

signoAnd returns signo:
	'y';
	
signoIgualdad returns signo:
	'=' | '!=';
	
signoComparacion returns signo:
	'<' | '>' | '>=' | '<=';

signoSuma returns signo:
	'+';
		
signoResta returns signo:
	'-';
	
signoMultiplicacion returns signo:
	'*';
	
signoDivision returns signo:
	'/';
	
signoModulo returns signo:
	'mod';
	
signoDiv returns signo:
	'div';
	
signoNo returns signo:
	'no';

Operacion returns Operacion:
	Or;

Or returns Operacion:
	And ({Or.left=current} signo_op=signoOr negacionesFinales+=('-')* negacionesFinales+=('no')* right=And)*;

And returns Operacion:
	Mod ({And.left=current} signo_op=signoAnd negacionesFinales+=('-')* negacionesFinales+=('no')* right=Mod)*;
	
Mod returns Operacion:
	Igualdad ({Mod.left=current} signo_op=signoModulo negacionesFinales+=('-')* negacionesFinales+=('no')* right=Igualdad)*;

Igualdad returns Operacion:
	Comparacion ({Igualdad.left=current} signo_op=signoIgualdad negacionesFinales+=('-')* negacionesFinales+=('no')* right=Comparacion)*;

Comparacion returns Operacion:
	SumaResta ({Comparacion.left=current} signo_op=signoComparacion negacionesFinales+=('-')* negacionesFinales+=('no')* right=SumaResta)*;

SumaResta returns Operacion:
	MultiplicacionDivision (({Suma.left=current} signo_op=signoSuma | {Resta.left=current} signo_op=signoResta) negacionesFinales+=('-')* negacionesFinales+=('no')* right=MultiplicacionDivision)*;

MultiplicacionDivision returns Operacion:
	Primaria (({Multiplicacion.left=current} signo_op=signoMultiplicacion | {DivisionEntera.left=current} signo_op=signoDivision | {DivisionReal.left=current} signo_op=signoDiv) negacionesFinales+=('-')* negacionesFinales+=('no')* right=Primaria)*;
	
	
OperacionIndice returns Operacion:
	OrIndice;

OrIndice returns Operacion:
	AndIndice ({Or.left=current} signo_op=signoOr right=AndIndice)*;

AndIndice returns Operacion:
	IgualdadIndice ({And.left=current} signo_op=signoAnd right=IgualdadIndice)*;

IgualdadIndice returns Operacion:
	ComparacionIndice ({Igualdad.left=current} signo_op=signoIgualdad right=ComparacionIndice)*;

ComparacionIndice returns Operacion:
	SumaRestaIndice ({Comparacion.left=current} signo_op=signoComparacion right=SumaRestaIndice)*;

SumaRestaIndice returns Operacion:
	MultiplicacionDivisionIndice (({Suma.left=current} signo_op=signoSuma | {Resta.left=current} signo_op=signoResta) right=MultiplicacionDivisionIndice)*;

MultiplicacionDivisionIndice returns Operacion:
	PrimariaIndice (({Multiplicacion.left=current} signo_op=signoMultiplicacion | {DivisionEntera.left=current} signo_op=signoDivision | {DivisionReal.left=current} signo_op=signoDiv) right=PrimariaIndice)*;

PrimariaIndice returns Operacion:
	{Entero} valor=EInt
	| {VariableID} nombre=EString;

Primaria returns Operacion:
	VariablesBasicas |
	VariablesComplejas
	| Funciones
	| OperacionParentesis;
	
OperacionCompleta returns Operacion:
	{OperacionCompleta} negacionesIniciales+=('-')* negacionesIniciales+=('no')* valor_operacion=Operacion;
	
OperacionParentesis returns Operacion:
	{OperacionParentesis} '(' negacionesFinales+=('-')* negacionesFinales+=('no')* valor_operacion=Operacion ')';
	
Funciones returns Operacion:
	({LlamadaFuncion} (nombre=NOMBRE_FUN) (operadores+=OperacionCompleta ( ',' operadores+=OperacionCompleta)* )? ')') |
	({FuncionInterna} (nombre=NombreInterna) (operadores+=OperacionCompleta ( ',' operadores+=OperacionCompleta)* )? ')');
	
CampoRegistro returns CampoRegistro:
	'.' nombre_campo=EString | '.' nombre_campo=EString '['(primerIndice=OperacionIndice)']' | '.' nombre_campo=EString '['(primerIndice=OperacionIndice)']['(segundoIndice=OperacionIndice)']';
	
VariablesComplejas returns Operacion:
	{ValorVector} ((nombre_vector=EString)'['(indice=OperacionIndice)']') (campos+=CampoRegistro)*
	| {ValorMatriz} ((nombre_matriz=EString)'['(primerIndice=OperacionIndice)']['(segundoIndice=OperacionIndice)']') (campos+=CampoRegistro)*
	| {ValorRegistro} nombre_registro=EString (campos+=CampoRegistro)+;
	
VariablesBasicas returns Operacion:
	 {Entero} valor=EInt
	| {Real} valor=EFloat
	| {CadenaCaracteres} valor=CAD
	| {Caracter} valor=CAR
	| {Logico} valor=Booleano
	| {VariableID} nombre=EString;

Sino returns Sino:
	{Sino}
	'si_no'
	(sentencias+=Sentencia)*
	(devuelve=Devolver)?;

Devolver returns Devolver:
	{Devolver}
	'devolver' devuelve=OperacionCompleta;
	
Parametro returns Parametro:
	paso=TipoPaso
	tipo=Tipo ": "
	variable=Variable;

Funcion returns Funcion:
	(tipo=TipoVariable)
	'funcion'
	nombre=NOMBRE_FUN(parametros+=Parametro ( "," parametros+=Parametro)*  )?')'
	('var'
	(declaraciones+=Declaracion)* )? 
	'inicio'
	(sentencias+=Sentencia)*
	(devuelve=Devolver)?
	'fin_funcion';
	
Procedimiento returns Procedimiento:
	'procedimiento'
	nombre=NOMBRE_FUN(parametros+=Parametro ( "," parametros+=Parametro)*  )?')'
	('var'
	(declaraciones+=Declaracion)* )?
	'inicio'
	(sentencias+=Sentencia)*
	'fin_procedimiento';
	
TipoPaso returns ecore::EString:
	'E' | 'E/S' | 'S';
	
Booleano returns ecore::EString:
	'verdadero' | 'falso';